# RFC #1: Academic Rays Local-First 架构
* **状态**：Draft
* **作者**：DuckRan
* **日期**：2026-01-17
* **目标**：定义以“本地优先”为核心的架构，弱化服务器依赖，实现单机全功能可用。

---

## 1. 架构决策：Local-First / Server-as-Sync

为了确保用户在单机环境下也能使用绝大多数功能，并保护数据私密性，我们从 **C/S 模式** 转向 **Local-First（本地优先）** 模式。

### 1.1 客户端职责 (Flutter App - 核心引擎)

* **计算重心**：
* **本地 OCR**：优先集成端侧 OCR 库（如 `google_ml_kit` 或 `screen_text_extractor`），处理简单的文本识别，降低对云端的依赖。
* **直接请求 LLM**：用户在客户端配置自己的 Gemini/Mathpix API Key，由客户端直接发起请求，无需经过中间服务器中转。


* **本地存储 (Single Truth)**：使用 **Drift (SQLite)** 作为“单一真理来源”。所有笔记、题目和配置信息首先存储在手机本地数据库中。
* **向量搜索 (Local RAG)**：研究使用端侧向量库（如 `sqlite_vec` 的集成）实现本地化的知识联想。

### 1.2 服务器职责 (Sync Node - 可选同步层)

* **极简后端**：服务器不再处理图片处理、OCR 或 AI 推理逻辑。
* **同步协调**：仅作为一个“加密存储箱”。接收客户端加密后的数据库增量包，用于手机、平板等多端间的数据同步。
* **可选对象存储**：仅当用户开启云同步时，作为图片文件的存储备份（如 WebDAV 或极简 S3 代理）。

---

## 2. 核心流程：去中心化归档 (Decentralized Flow)

1. **Capture**: 用户拍摄图片，Flutter 客户端立即存入本地文件系统。
2. **Edge Processing**:
* 客户端尝试使用端侧模型进行初步分类。
* 若有网络且配置了 Key，客户端**直接调用** Mathpix/Gemini 接口获取 Markdown 结果。


3. **Local Indexing**: 结果直接写入本地数据库，UI 立即更新。
4. **Lazy Sync (Optional)**：当网络可用且用户开启同步时，客户端将操作日志（Change Log）推送到同步服务器。

---

## 3. 跨端同步机制：Change-based Sync

由于没有中心服务器逻辑，同步逻辑需更加健壮：

### 3.1 客户端日志同步

* **Operation Log**: 客户端记录每一次增删改操作（CRDT 思想）。
* **E2EE (端到端加密)**：数据在上传服务器前进行本地加密，服务器无法感知用户笔记内容，仅负责存储。

### 3.2 冲突处理

* **Device IDs**: 每个设备拥有唯一标识，同步时通过逻辑时钟或版本号合并差异。

---

## 4. 针对团队的讨论要点

1. **端侧计算压力**：如果要在手机端直接运行简单的 OCR 或较小的模型，Flutter 的性能开销是否可控？
2. **API 暴露风险**：用户直接在 App 内填入 API Key，如何确保 Key 存储的安全（建议使用 `flutter_secure_storage`）？
3. **无服务器下的 RAG**：在手机端处理海量笔记的向量检索，目前的端侧技术方案（如本地向量索引）是否足够成熟？
4. **成本优势**：强调这种架构下，我们几乎**零服务器运行成本**，且极大地保护了用户隐私。

---

## 5. 下一步行动建议

1. **调研端侧 OCR**：测试 `google_ml_kit` 对公式识别的局限性，确定何时必须请求云端接口。
2. **设计本地数据模型**：设计支持“操作日志”的数据库表结构，为未来的多端同步留出空间。
3. **Flutter Key 管理**：实现一套安全的本地配置界面，让用户管理自己的 API 密钥。

---

### 为什么这样改？

1. **符合团队初衷**：明确了“单机也可使用绝大多数功能”，去掉了原版中“后端归档引擎”的重型描述。
2. **职责平移**：把 OCR、分析、分类的职责从 FastAPI 挪到了 Flutter 内部。
3. **隐私驱动**：强调了服务器仅做加密同步，不触碰用户原始数据，这在学习/笔记类产品中是一个很大的卖点。